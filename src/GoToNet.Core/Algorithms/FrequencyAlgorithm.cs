// /src/GoToNet.Core/Algorithms/FrequencyAlgorithm.cs
using GoToNet.Core.Interfaces;
using GoToNet.Core.Models;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace GoToNet.Core.Algorithms
{
    /// <summary>
    /// Implements a prediction algorithm based purely on the frequency of page/feature visits.
    /// It suggests items that an individual user has visited most often.
    /// </summary>
    public class FrequencyAlgorithm : IPredictionAlgorithm
    {
        /// <summary>
        /// Gets the unique name of this algorithm.
        /// </summary>
        public string Name => "Frequency";

        /// <summary>
        /// Gets or sets the weight applied to the scores generated by this algorithm
        /// when combined with other algorithms in the GoToPredictionEngine.
        /// </summary>
        public double Weight { get; set; } = 1.0; // Default weight

        // Stores the frequency of each page/feature per user.
        // Key: UserId -> Value: (Dictionary of Page/Feature Name -> Count)
        private readonly ConcurrentDictionary<string, ConcurrentDictionary<string, int>> _userPageFrequencies = new();

        /// <inheritdoc />
        public Task TrainAsync(IEnumerable<NavigationEvent> historicalData, IAlgorithmProgressReporter progressReporter) // MODIFIED HERE
        {
            string algoName = Name;
            progressReporter.ReportProgress(algoName, "Démarrage du calcul des fréquences", 0); // Report start

            _userPageFrequencies.Clear(); // Clear existing frequencies to perform a full re-train.

            foreach (var interaction in historicalData)
            {
                if (string.IsNullOrEmpty(interaction.UserId)) continue;
                var userFreq = _userPageFrequencies.GetOrAdd(interaction.UserId, new ConcurrentDictionary<string, int>());
                userFreq.AddOrUpdate(interaction.CurrentPageOrFeature, 1, (key, oldValue) => oldValue + 1);
            }

            Console.WriteLine($"[FrequencyAlgorithm] Trained with {historicalData.Count()} events.");
            progressReporter.ReportProgress(algoName, "Fréquences calculées", 100, true, $"Traités {historicalData.Count()} événements."); // Report completion
            return Task.CompletedTask;
        }

        /// <inheritdoc />
        public Task<IEnumerable<SuggestedItem>> PredictAsync(
            string userId,
            string? currentContext, // Not used by FrequencyAlgorithm
            int numberOfSuggestions,
            IDictionary<string, string>? contextData = null) // Not used by FrequencyAlgorithm
        {
            // Try to get the frequency data for the specific user
            if (!_userPageFrequencies.TryGetValue(userId, out var userFreq) || userFreq.Count == 0)
            {
                // If no history exists for the user, return an empty list
                return Task.FromResult<IEnumerable<SuggestedItem>>(Enumerable.Empty<SuggestedItem>());
            }

            // Order the user's visited pages/features by frequency in descending order,
            // select the top N items, and convert them into SuggestedItem objects.
            var suggestions = userFreq
                .OrderByDescending(kvp => kvp.Value) // Sort by visit count (Value)
                .Select(kvp => new SuggestedItem
                {
                    Name = kvp.Key,              // The name of the page/feature
                    Score = kvp.Value * Weight,  // Calculate score by applying the algorithm's weight
                    Reason = Name                // Indicate the source of the suggestion
                })
                .Take(numberOfSuggestions)       // Take only the requested number of suggestions
                .ToList();                       // Convert to a List

            Console.WriteLine($"[FrequencyAlgorithm] Predicted {suggestions.Count} items for user '{userId}'.");
            return Task.FromResult<IEnumerable<SuggestedItem>>(suggestions.AsEnumerable());
        }
    }
}